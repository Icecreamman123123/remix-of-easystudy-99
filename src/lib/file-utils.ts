import { jsPDF } from "jspdf";
import { saveAs } from "file-saver";

// ============ IMPORT UTILITIES ============

export async function extractTextFromFile(file: File): Promise<string> {
  const ext = file.name.split('.').pop()?.toLowerCase() || '';
  
  switch (ext) {
    case 'txt':
    case 'md':
    case 'csv':
      return file.text();
    
    case 'docx':
      return extractTextFromDocx(file);
    
    case 'pptx':
      return extractTextFromPptx(file);
    
    case 'xlsx':
    case 'xls':
      return extractTextFromXlsx(file);
    
    default:
      throw new Error(`Unsupported file type: .${ext}`);
  }
}

async function extractTextFromDocx(file: File): Promise<string> {
  const mammoth = await import('mammoth');
  const arrayBuffer = await file.arrayBuffer();
  const result = await mammoth.extractRawText({ arrayBuffer });
  return result.value;
}

async function extractTextFromPptx(file: File): Promise<string> {
  // PPTX files are ZIP archives containing XML slides
  const JSZip = (await import('xlsx')).default;
  // Use a simpler approach: read the PPTX XML directly
  const arrayBuffer = await file.arrayBuffer();
  
  // PPTX is a ZIP file, we can use the browser's built-in decompression
  // by treating it as an xlsx-compatible format or parsing XML
  try {
    const XLSX = await import('xlsx');
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
    // xlsx can sometimes extract text from pptx-like formats
    let text = '';
    workbook.SheetNames.forEach(name => {
      const sheet = workbook.Sheets[name];
      text += XLSX.utils.sheet_to_txt(sheet) + '\n\n';
    });
    if (text.trim()) return text;
  } catch {
    // Fallback: try to extract raw XML text from the zip
  }

  // Basic XML extraction fallback for PPTX
  const blob = new Blob([arrayBuffer]);
  const text = await blob.text();
  // Strip XML tags for a rough extraction
  const stripped = text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
  if (stripped.length > 50) return stripped;
  
  throw new Error("Could not extract text from this PPTX file. Try converting it to PDF first.");
}

async function extractTextFromXlsx(file: File): Promise<string> {
  const XLSX = await import('xlsx');
  const arrayBuffer = await file.arrayBuffer();
  const workbook = XLSX.read(arrayBuffer, { type: 'array' });
  
  let fullText = '';
  workbook.SheetNames.forEach(name => {
    const sheet = workbook.Sheets[name];
    const csv = XLSX.utils.sheet_to_csv(sheet);
    fullText += `--- ${name} ---\n${csv}\n\n`;
  });
  
  return fullText.trim();
}

// ============ EXPORT UTILITIES ============

export type ExportFormat = 'pdf' | 'txt' | 'csv' | 'docx';

interface ExportData {
  title: string;
  content: string;
  items?: { question: string; answer: string; hint?: string }[];
}

export function exportToTxt(data: ExportData) {
  let text = `${data.title}\n${'='.repeat(data.title.length)}\n\n`;
  
  if (data.items && data.items.length > 0) {
    data.items.forEach((item, i) => {
      text += `${i + 1}. Q: ${item.question}\n   A: ${item.answer}\n`;
      if (item.hint) text += `   Hint: ${item.hint}\n`;
      text += '\n';
    });
  } else {
    text += data.content;
  }
  
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  saveAs(blob, `${sanitizeFileName(data.title)}.txt`);
}

export function exportToCsv(data: ExportData) {
  if (!data.items || data.items.length === 0) {
    // Export content as single-cell CSV
    const blob = new Blob([data.content], { type: 'text/csv;charset=utf-8' });
    saveAs(blob, `${sanitizeFileName(data.title)}.csv`);
    return;
  }
  
  const rows = [
    ['#', 'Question', 'Answer', 'Hint'],
    ...data.items.map((item, i) => [
      String(i + 1),
      csvEscape(item.question),
      csvEscape(item.answer),
      csvEscape(item.hint || ''),
    ])
  ];
  
  const csv = rows.map(row => row.join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
  saveAs(blob, `${sanitizeFileName(data.title)}.csv`);
}

export function exportToPdf(data: ExportData) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - margin * 2;
  let y = margin;

  // Title
  doc.setFontSize(18);
  doc.setFont("helvetica", "bold");
  doc.text(data.title, pageWidth / 2, y, { align: "center" });
  y += 12;

  doc.setFontSize(9);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(128, 128, 128);
  doc.text(`Generated by StudyAce â€¢ ${new Date().toLocaleDateString()}`, pageWidth / 2, y, { align: "center" });
  doc.setTextColor(0, 0, 0);
  y += 12;

  if (data.items && data.items.length > 0) {
    data.items.forEach((item, i) => {
      if (y > pageHeight - 50) { doc.addPage(); y = margin; }
      
      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      const qLines = doc.splitTextToSize(`${i + 1}. Q: ${item.question}`, contentWidth);
      doc.text(qLines, margin, y);
      y += qLines.length * 5 + 3;
      
      doc.setFont("helvetica", "normal");
      doc.setTextColor(60, 60, 60);
      const aLines = doc.splitTextToSize(`A: ${item.answer}`, contentWidth);
      doc.text(aLines, margin, y);
      y += aLines.length * 5 + 3;
      doc.setTextColor(0, 0, 0);
      
      if (item.hint) {
        doc.setFontSize(9);
        doc.setFont("helvetica", "italic");
        doc.setTextColor(100, 100, 100);
        const hLines = doc.splitTextToSize(`Hint: ${item.hint}`, contentWidth);
        doc.text(hLines, margin, y);
        y += hLines.length * 4;
        doc.setTextColor(0, 0, 0);
      }
      
      y += 4;
      doc.setDrawColor(220, 220, 220);
      doc.line(margin, y, pageWidth - margin, y);
      y += 8;
    });
  } else {
    // Plain text content
    doc.setFontSize(11);
    doc.setFont("helvetica", "normal");
    const lines = doc.splitTextToSize(stripMarkdown(data.content), contentWidth);
    lines.forEach((line: string) => {
      if (y > pageHeight - 20) { doc.addPage(); y = margin; }
      doc.text(line, margin, y);
      y += 5;
    });
  }

  doc.save(`${sanitizeFileName(data.title)}.pdf`);
}

// ============ HELPERS ============

function csvEscape(str: string): string {
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

function sanitizeFileName(name: string): string {
  return name.replace(/[^a-zA-Z0-9-_ ]/g, '').replace(/\s+/g, '-').substring(0, 50) || 'export';
}

function stripMarkdown(md: string): string {
  return md
    .replace(/#{1,6}\s/g, '')
    .replace(/\*\*(.*?)\*\*/g, '$1')
    .replace(/\*(.*?)\*/g, '$1')
    .replace(/`(.*?)`/g, '$1')
    .replace(/\[(.*?)\]\(.*?\)/g, '$1')
    .replace(/---/g, '')
    .replace(/>/g, '');
}

// Get supported file extensions for import
export const SUPPORTED_IMPORT_EXTENSIONS = '.pdf,.jpg,.jpeg,.png,.gif,.webp,.docx,.pptx,.csv,.txt,.md,.xlsx,.xls';
export const SUPPORTED_IMPORT_MIME = 'application/pdf,image/*,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.presentationml.presentation,text/csv,text/plain,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel';
